import { NextResponse } from "next/server";
import { PDFDocument, StandardFonts, rgb } from "pdf-lib";
import { Buffer } from "buffer";

export const runtime = "nodejs";

type Body = {
  title?: string;
  filename?: string;
  content: string;
};

function wrapLines(text: string, maxChars: number) {
  const lines: string[] = [];
  const paragraphs = text.replace(/\r\n/g, "\n").split("\n");

  for (const p of paragraphs) {
    if (p.trim() === "") {
      lines.push("");
      continue;
    }

    const words = p.split(/\s+/);
    let line = "";

    for (const w of words) {
      const candidate = line ? `${line} ${w}` : w;
      if (candidate.length <= maxChars) line = candidate;
      else {
        if (line) lines.push(line);
        line = w;
      }
    }
    if (line) lines.push(line);
  }

  return lines;
}

export async function POST(req: Request) {
  const body = (await req.json()) as Body;

  if (!body?.content || typeof body.content !== "string") {
    return NextResponse.json({ error: "Missing content" }, { status: 400 });
  }

  const title = body.title ?? "STATEMENT IN SUPPORT OF CLAIM";
  const filename = body.filename ?? "ClaimCompass-Statement.pdf";

  const pdfDoc = await PDFDocument.create();
  const font = await pdfDoc.embedFont(StandardFonts.TimesRoman);
  const fontBold = await pdfDoc.embedFont(StandardFonts.TimesRomanBold);

  const pageWidth = 612;  // 8.5in
  const pageHeight = 792; // 11in
  const margin = 72;      // 1 inch
  const fontSize = 12;
  const lineHeight = 18;

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let y = pageHeight - margin;

  const today = new Date().toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  });

  // Header block (top right)
  page.drawText(`Generated by ClaimCompass`, {
    x: pageWidth - margin - 200,
    y,
    size: 9,
    font,
    color: rgb(0.5, 0.5, 0.5),
  });

  page.drawText(today, {
    x: pageWidth - margin - 200,
    y: y - 12,
    size: 9,
    font,
    color: rgb(0.5, 0.5, 0.5),
  });

  y -= 40;

  // Title centered
  const titleWidth = fontBold.widthOfTextAtSize(title, 16);
  page.drawText(title, {
    x: (pageWidth - titleWidth) / 2,
    y,
    size: 16,
    font: fontBold,
  });

  y -= 30;

  // Horizontal rule
  page.drawLine({
    start: { x: margin, y },
    end: { x: pageWidth - margin, y },
    thickness: 1,
    color: rgb(0.8, 0.8, 0.8),
  });

  y -= 25;

  const lines = wrapLines(body.content, 95);

  for (const line of lines) {
    if (y < margin + lineHeight) {
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      y = pageHeight - margin;
    }

    if (line === "") {
      y -= lineHeight;
      continue;
    }

    page.drawText(line, {
      x: margin,
      y,
      size: fontSize,
      font,
      lineHeight,
    });

    y -= lineHeight;
  }

  y -= 30;

  // Signature block
  page.drawLine({
    start: { x: margin, y },
    end: { x: margin + 250, y },
    thickness: 1,
    color: rgb(0, 0, 0),
  });

  page.drawText("Signature", {
    x: margin,
    y: y - 14,
    size: 10,
    font,
  });

  page.drawLine({
    start: { x: pageWidth - margin - 200, y },
    end: { x: pageWidth - margin, y },
    thickness: 1,
    color: rgb(0, 0, 0),
  });

  page.drawText("Date", {
    x: pageWidth - margin - 200,
    y: y - 14,
    size: 10,
    font,
  });

  // Page numbers
  const pages = pdfDoc.getPages();
  pages.forEach((p, index) => {
    const text = `Page ${index + 1} of ${pages.length}`;
    p.drawText(text, {
      x: pageWidth - margin - 80,
      y: 20,
      size: 9,
      font,
      color: rgb(0.5, 0.5, 0.5),
    });
  });

  const pdfBytes = await pdfDoc.save();
  const nodeBuffer = Buffer.from(pdfBytes);

  return new NextResponse(nodeBuffer, {
    status: 200,
    headers: {
      "Content-Type": "application/pdf",
      "Content-Disposition": `attachment; filename="${filename}"`,
      "Cache-Control": "no-store",
    },
  });
}
